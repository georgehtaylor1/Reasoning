import java.io.PrintStream;
import java.util.HashSet;
import java.util.Map.Entry;

public class DPLLProof implements Proof {

	private boolean proven = false;

	private Model model;
	private Formula formula;
	
	private long executionTime;

	/**
	 * Create a new DPLL proof object for the specified formula
	 * 
	 * @param formula
	 *            The formula to be proven
	 */
	public DPLLProof(Formula formula) {
		setFormula(formula);
		setProven(false);
	}

	/* (non-Javadoc)
	 * @see Proof#prove()
	 */
	@Override
	public void prove() {
		prove(false, System.out);
	}

	/* (non-Javadoc)
	 * @see Proof#prove(boolean)
	 */
	@Override
	public void prove(boolean verbose) {
		prove(verbose, System.out);
	}

	/* (non-Javadoc)
	 * @see Proof#prove(boolean, java.io.PrintStream)
	 */
	@Override
	public void prove(boolean verbose, PrintStream output) {
		// Attempt to garbage collect to limit execution time anomalies
		System.gc();
		
		long startTime = System.nanoTime();
		model = new Model();
		for (Clause c : formula) {
			for (Literal l : c) {
				model.put(l.getSymbol(), Interpretation.FREE);
			}
		}
		if (verbose) {
			output.println("Initialized model:");
			output.println(model.toString());
		}

		Model newModel = proofRecurse(model, formula, verbose, output);
		setProven(true);
		if (newModel == null) {
			getFormula().setSatisfiable(false);
		} else {
			getFormula().setSatisfiable(true);
			setModel(newModel);
		}
		
		long endTime = System.nanoTime();
		setExecutionTime(endTime - startTime);
		
		if (verbose)
			output.print(this.toString());
		
		getFormula().setProof(this);
	}

	/**
	 * Recursively attempt to prove the formula using DPLL
	 * 
	 * @param m
	 *            The model for the current recursion
	 * @param f
	 *            The formula that the current recursion is attempting to reduce
	 * @return The model generated by the proof or null if it is unsatisfiable
	 */
	private Model proofRecurse(Model m, Formula f, boolean verbose, PrintStream output) {

		if (verbose)
			output.println("Recursing on: " + f.toString());

		if (f.isEmpty())
			return m;

		// If an empty clause has been created then the formula is unsatisfiable
		for (Clause c : f)
			if (c.isEmpty())
				return null;

		Model m1 = (Model) m.clone();
		Formula f1 = (Formula) f.clone();

		//Unit propagation
		Clause unit = getUnitClause(f1);
		if (unit != null) {
			Literal lit = (Literal) unit.toArray()[0];
			if (verbose)
				output.println("Unit literal on: " + lit.toString());
			m1.put(lit.getSymbol(), lit.isNegation() ? Interpretation.FALSE : Interpretation.TRUE);

			//remove any clauses containing the literal from the formula
			cleanFormula(lit, f1);

			return proofRecurse(m1, f1, verbose, output);
		}

		// pure literal
		HashSet<Literal> allLiterals = new HashSet<Literal>();
		for (Clause c : f1) {
			allLiterals.addAll(c);
		}
		for (Entry<String, Interpretation> e : m1.entrySet()) {
			if (e.getValue() == Interpretation.FREE) {
				Literal testLiteral = new Literal(e.getKey(), true);
				if (allLiterals.contains(testLiteral) && !allLiterals.contains(testLiteral.getCompliment())) {
					if (verbose)
						output.println(String.format("Pure literal on: %s", testLiteral.toString()));
					e.setValue(Interpretation.TRUE);
					f1.removeIf((Clause c) -> c.contains(testLiteral));
					return proofRecurse(m1, f1, verbose, output);

				}
				if (!allLiterals.contains(testLiteral) && allLiterals.contains(testLiteral.getCompliment())) {
					if (verbose)
						output.println(String.format("Pure literal on: %s", testLiteral.getCompliment().toString()));
					e.setValue(Interpretation.FALSE);
					f1.removeIf((Clause c) -> c.contains(testLiteral.getCompliment()));
					return proofRecurse(m1, f1, verbose, output);
				}
			}
		}

		//Try and guess some values
		Literal firstLiteral = ((Literal) ((Clause) f1.toArray()[0]).toArray()[0]);

		m1.put(firstLiteral.getSymbol(), firstLiteral.isNegation() ? Interpretation.FALSE : Interpretation.TRUE);
		Formula f2 = (Formula) f1.clone();
		cleanFormula(firstLiteral, f2);
		Model proof = proofRecurse(m1, f2, verbose, output);
		if (proof != null) {
			return proof;
		}

		m1.put(firstLiteral.getSymbol(), !firstLiteral.isNegation() ? Interpretation.FALSE : Interpretation.TRUE);
		f2 = (Formula) f1.clone();
		cleanFormula(firstLiteral.getCompliment(), f2);
		proof = proofRecurse(m1, f2, verbose, output);
		if (proof != null) {
			return proof;
		}

		//Nothing has worked, the formula is unsatisfiable
		return null;

	}

	/**
	 * Remove all clauses that evaluate to true under the given literal and remove the compliment of the literal from any clauses
	 * 
	 * @param l
	 *            The literal to be operated on
	 * @param f
	 *            The formula to be cleaned
	 */
	private void cleanFormula(Literal l, Formula f) {
		f.removeIf((Clause c) -> c.contains(l));
		for (Clause c : f) {
			c.remove(l.getCompliment());
		}
	}

	/**
	 * Get the first occurrence of a unit clause
	 * 
	 * @param f
	 *            The formula to find unit clauses in
	 * @return The unit clause that has been discovered or null if none could be found
	 */
	private Clause getUnitClause(Formula f) {
		for (Clause c : f) {
			if (c.size() == 1)
				return c;
		}
		return null;
	}

	private Model unitPropagation(Model m, Formula f) {
		return null;
	}

	private Model pureLiteral(Model m, Formula f) {
		return null;
	}

	/* (non-Javadoc)
	 * @see Proof#isProven()
	 */
	@Override
	public boolean isProven() {
		return this.proven;
	}

	/* (non-Javadoc)
	 * @see Proof#setProven(boolean)
	 */
	@Override
	public void setProven(boolean proven) {
		this.proven = true;
	}

	/**
	 * Get the model generated by the proof
	 * 
	 * @return The model as generated by the proof
	 */
	public Model getModel() {
		return model;
	}

	/**
	 * Set the model for the given formula
	 * 
	 * @param model
	 *            The model generated by a proof for the formula
	 */
	public void setModel(Model model) {
		this.model = model;
	}

	/**
	 * Get the formula that this proof applies to
	 * 
	 * @return The formula to which this proof applies
	 */
	public Formula getFormula() {
		return formula;
	}

	/**
	 * Set the formula to which this proof applies
	 * 
	 * @param formula
	 *            The new formula that the proof is applied to
	 */
	public void setFormula(Formula formula) {
		this.formula = formula;
	}

	/* (non-Javadoc)
	 * @see java.lang.Object#toString()
	 */
	@Override
	public String toString() {
		String r = "#===============================================#\n";
		r = r + "#                                               #\n";
		r = r + String.format("# Proof for: %-34s #\n", getFormula().getOriginalFormula());
		r = r + "#                                               #\n";
		if (isProven()) {
			r = r + "#                                               #\n";

			if (getFormula().isSatisfiable()) {
				r = r + "# Generated model:                              #\n";
				r = r + "#                                               #\n";
				for (Entry<String, Interpretation> e : getModel().entrySet()) {
					r = r + String.format("#   %10s -> %-29s #\n", e.getKey(), e.getValue().toString());
				}
			} else
				r = r + "# This formula is unsatisfiable.                #\n";

			r = r + "#                                               #\n";
			r = r + "# Execution completed in:                       #\n";
			r = r + String.format("# %33d nanoseconds #\n", getExecutionTime());
		} else {
			r = r + "# This formula is not yet proven                #\n";
		}
		r = r + "#                                               #\n";
		r = r + "#===============================================#\n";
		return r;
	}

	public long getExecutionTime() {
		return executionTime;
	}

	public void setExecutionTime(long executionTime) {
		this.executionTime = executionTime;
	}

}
